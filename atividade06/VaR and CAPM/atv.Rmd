---
title: "Avaliação Parcial 2"
author: "Alysson da Silva Moura"
date: "24/06/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Questões

Baixar dados de 01/01/2021 a 15/06/2022 da ação selecionada. Vamos analisar 6 trimestres.

1.  Introdução (2 PONTOS) a) Análise estatística e gráfica da série histórica em nível e de retornos. b) Baixe os dados de um empresa concorrente e observe se o comportamento gráfico é semelhante (colocar as duas séries no mesmo gráfico).

2.  Value at Risk: Considere um investimento de R\$100mil e o Z=-1,645 (nível de confiança de 95%). (4 PONTOS) a) Calcular para cada um dos 6 trimestres o Value at Risk Relativo e Absoluto b) Usar gráficos de barras para analisar o comportamento do risco ao longo dos 6 trimestres.

3.  CAPM: Considere o ativo livre de risco 6%a.a. e base 252. (4 PONTOS)

    a)  Calcular para cada um dos 6 trimestres o BETA do CAPM.
    b)  Usar gráficos de barra para analisar o comportamento do BETA ao longo dos 6 trimestres.
    c)  Analisar dentro de cada trimestre se o retorno médio do ativo é justo pela equação do CAPM, e se ativo está sobreprecificado ou subprecificado?

------------------------------------------------------------------------

# Pacotes

```{r pacotes, message=FALSE, warning=FALSE}
library(quantmod)
library(tidyverse)
library(patchwork)
library(stargazer)
```

Os \*ticks\* escolhidos foram $BTC$ e $ETH$, vamos utilizar o pacote `quantmod` podemos usar a função `quantmod::getSymbols()` para pegar os dados do yahoo:

```{r pegando os dados}
btc <- quantmod::getSymbols("BTC-USD",
                            src = "yahoo",
                            from = as.Date("2021-01-01"),
                            to = as.Date("2021-06-15"), auto.assign = F)
eth <- quantmod::getSymbols("ETH-USD", src = "yahoo",
                            from = as.Date("2021-01-01"),
                            to = as.Date("2021-06-15"), auto.assign = F)
```

Primeiro pegaremos só o preço de fechamento dessas ações:

```{r fechamento}
btc_p <- btc$`BTC-USD.Close`
eth_p <- eth$`ETH-USD.Close`
```

Para juntar conseguir juntar os dois stocks precisaremos sair do formato `xts` para um `DataFrame`, para isso foi criado uma função chamada `into_df` que vai converter esse formato. A partir disso, pode-se *plotar* os gráficos do BTC-USD e do ETH-USD dos retornos diários dos ativos, e outra para retornar os ativos em nível.

```{r transformando em df}
into_df <- function (data, ticker) {
  data.frame(date = zoo::index(data),
             price = zoo::coredata(data),
             ticker = rep(ticker, length(zoo::coredata(data)))) %>%
    setNames(c("date", "price", "ticker")) %>%
    dplyr::arrange(dplyr::desc(date))
}
```

Para conseguir os retornos diários em porcentagem foi utilizado a função `quantmod::dailyReturn()` que dá os retornos diários do ativo, e passaremos os resultados para a função `into_df` que retorna um `DataFrame` com a data, valor e o *ticker* informado

```{r retornos diários}

btc_r_df <- btc_p %>% dailyReturn() %>% into_df("btc")
eth_r_df <- eth_p %>% dailyReturn() %>% into_df("eth")

```

```{r df de retornos}
head(btc_r_df)
```

Foi combinado os dois `DataFrame`'s em um só, na variável `combined_df_r`, e, a partir dela, foi criado o plot dos retornos diários

```{r retornos combinados}
combined_df_r <- rbind(btc_r_df, eth_r_df) 
```

```{r plot retorno diario}
dailyPlot <- combined_df_r %>%
  ggplot(aes(x = date, y = price, group = ticker, colour = ticker)) +
   geom_line(show.legend = F) +
   labs(y = "Retorno (%)", x = "", title ="Retorno (em %)") +
    facet_wrap(~ticker, scales = "free_y", ncol = 1) +
  scale_y_continuous(labels = scales::percent) +
  scale_color_discrete(limits = c("btc", "eth"),
                       labels = c("BTC-US$", "ETH_US$")) +
  theme_minimal(base_size = 9) +
  theme(plot.title = element_text(hjust = 0.5))
```

e para o gráfico em nível:

```{r precos combinados}
btc_df <- btc_p %>% into_df("btc")
eth_df <- eth_p %>% into_df("eth")

combined_df <- rbind(btc_df, eth_df)
```

```{r plot em nível}
levelPlot <- combined_df %>%
  ggplot(aes(x = date, y = log(price), colour = ticker)) +
  geom_line() +
  labs(y = "log(Preço (US$))", x = "",
       title = paste0("log(Preço (US$)) dos Stocks"),
       colour = "Stock") +
  scale_color_discrete(limits = c("btc", "eth"),
                       labels = c("BTC-US$", "ETH-US$")) +
  theme_minimal(base_size = 9) +
  theme(plot.title = element_text(hjust = 0.5))
```

Então chamamos a função `plotData` para os valores do `btc_p` e `eth_p` e utilizamos o pacote `patchwork` para dividir os *plots*:

```{r plotando os tickers, eval=FALSE, include=TRUE}

plots <- dailyPlot | levelPlot

plots
```

```{r include=FALSE}
plots <- dailyPlot | levelPlot
```

```{r BTC x ETH, echo=FALSE, message=FALSE, warning=FALSE}

pngfile <- fs::path(knitr::fig_path(),  "btcxeth.png")
ggsave(
  pngfile, 
  plots, 
  device = ragg::agg_png, 
  width = 20, height = 14, units = "cm", res = 600,
  scaling = 1
)

knitr::include_graphics(pngfile)
```

E as estatísticas descritivas:

```{r descritivo, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

dados <- merge(btc_p, eth_p, all = F) %>%
  coredata() %>%
  as.data.frame() %>%
  rename(btc = BTC.USD.Close, eth = ETH.USD.Close)

dados |>
  stargazer(header = F,
            title = "Estatísticas descritivas",
            type = "latex",
            column.labels = "",
            covariate.labels = c("BTC-USD", "ETH-USD"))
```
